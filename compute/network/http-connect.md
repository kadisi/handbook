# http 链接



> 本文以HTTP请求和响应的过程来讲解涉及到的相关知识点。

#### 一、 HTTP请求和响应步骤

![](../../.gitbook/assets/image%20%289%29.png)

以上完整表示了HTTP请求和响应的7个步骤，下面从TCP/IP协议模型的角度来理解HTTP请求和响应如何传递的。

#### 二、TCP/IP协议

TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。

HTTP协议就是基于TCP/IP协议模型来传输信息的。  
![](//upload-images.jianshu.io/upload_images/3985563-e533b0cdd7fca359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590/format/webp)  


\(1\). 链路层

也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。

\(2\). 网络层

也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。

IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。

ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。

IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。

\(3\). 传输层

主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。

TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。

UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。  
 \(4\). 应用层

应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。  
![](//upload-images.jianshu.io/upload_images/3985563-1891c256487e9d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/757/format/webp)  


当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。![](//upload-images.jianshu.io/upload_images/3985563-5d534a249b4825a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/780/format/webp)  


当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。

通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。

下面这张图更清楚明白：![](//upload-images.jianshu.io/upload_images/3985563-ecf824604debcdf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/671/format/webp)

下面具体来看如何进行一步步操作的。

#### 三、TCP三次握手

TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。  
![](//upload-images.jianshu.io/upload_images/3985563-f2fe3775bd2678c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp)

第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN\_SEND状态，等待服务器的确认；

第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1\(Sequence Number+1\)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN\_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

**为什么要三次握手**

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

**具体例子：**“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

#### 四、HTTP协议

**Http是什么？**

通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。

**四个基于：**

**请求与响应：**客户端发送请求，服务器端响应数据

**无状态的：**协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。

**应用层：**Http是属于应用层的协议，配合TCP/IP使用。

**TCP/IP：**Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。

**针对无状态的一些解决策略：**

有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。

HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。  
 等等还有很多。。。。。。

下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。

HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。

#### 五、HTTP请求报文

一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。  
![](//upload-images.jianshu.io/upload_images/3985563-cd59a3899ef546e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/466/format/webp)

**1.请求行**

请求行分为三个部分：请求方法、请求地址和协议版本

**请求方法**

HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。

最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。

**请求地址**

URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。

组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;

**端口和路径有时可以省略（HTTP默认端口号是80）**

如下例：  
![](//upload-images.jianshu.io/upload_images/3985563-54ce5eca048253be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/725/format/webp)  


有时会带参数，GET请求

**协议版本**

协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1

**2.请求头部**

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。

常见请求头如下：  
![](//upload-images.jianshu.io/upload_images/3985563-539378eee14fa322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/593/format/webp)  


请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。

**3.请求数据**

可选部分，比如GET请求就没有请求数据。

下面是一个POST方法的请求报文：

> POST 　/index.php　HTTP/1.1 　　 请求行  
>  Host: localhost  
>  User-Agent: Mozilla/5.0 \(Windows NT 5.1; rv:10.0.2\) Gecko/20100101 Firefox/10.0.2　　请求头  
>  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,_/_;q=0.8  
>  Accept-Language: zh-cn,zh;q=0.5  
>  Accept-Encoding: gzip, deflate  
>  Connection: keep-alive  
>  Referer: [http://localhost/](https://link.jianshu.com?t=http://localhost/)  
>  Content-Length：25  
>  Content-Type：application/x-www-form-urlencoded  
>  　　空行  
>  username=aa&password=1234　　请求数据

#### 六、HTTP响应报文

![](//upload-images.jianshu.io/upload_images/3985563-c6ee8f8526f59fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480/format/webp)

HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。

**1.状态行**

由3部分组成，分别为：协议版本，状态码，状态码描述。

其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。

**状态码**

状态代码为3位数字。  
 1xx：指示信息--表示请求已接收，继续处理。  
 2xx：成功--表示请求已被成功接收、理解、接受。  
 3xx：重定向--要完成请求必须进行更进一步的操作。  
 4xx：客户端错误--请求有语法错误或请求无法实现。  
 5xx：服务器端错误--服务器未能实现合法的请求。

下面列举几个常见的：![](//upload-images.jianshu.io/upload_images/3985563-8f3bf059bc4365e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609/format/webp)

**2.响应头部**

与请求头部类似，为响应报文添加了一些附加信息

常见响应头部如下：![](//upload-images.jianshu.io/upload_images/3985563-33ed95479f541a07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp)

**3.响应数据**

用于存放需要返回给客户端的数据信息。

下面是一个响应报文的实例：

> HTTP/1.1 200 OK　　状态行

Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部  
 Server: Apache/2.2.8 \(Win32\) PHP/5.2.5  
 X-Powered-By: PHP/5.2.5  
 Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/  
 Expires: Thu, 19 Nov 1981 08:52:00 GMT  
 Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0  
 Pragma: no-cache  
 Content-Length: 4393  
 Keep-Alive: timeout=5, max=100  
 Connection: Keep-Alive  
 Content-Type: text/html; charset=utf-8

> 空行  
>  &lt;html&gt;　　响应数据  
>  &lt;head&gt;  
>  &lt;title&gt;HTTP响应示例&lt;title&gt;  
>  &lt;/head&gt;  
>  &lt;body&gt;  
>  Hello HTTP!  
>  &lt;/body&gt;  
>  &lt;/html&gt;

关于请求头部和响应头部的知识点很多，这里只是简单介绍。

通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接。

#### 七、TCP四次挥手

当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。  
![](//upload-images.jianshu.io/upload_images/3985563-c1c59148f8b26c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/691/format/webp)  


第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN\_WAIT\_1状态；这表示主机1没有数据要发送给主机2了；

第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN\_WAIT\_2状态；主机2告诉主机1，我“同意”你的关闭请求；

第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST\_ACK状态；

第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME\_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

**为什么要四次分手**

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

通过以上步骤便完成了HTTP的请求和响应，进行了数据传递，这其中涉及到需要知识点，都进行了逐一了解。  



# https 链接



## HTTPS加密过程和TLS证书验证

#### 前言

大家都知道，苹果在[2016年WWDC](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.apple.com%2Fwwdc%2F)上宣布了关于应用需要强制使用`HTTPS`的规定。这也算是个好消息吧，虽然开发者们可能需要适配下`HTTPS`，但是我们的应用可算是披上一个安全的保护罩了。本篇文章就算是笔者在学习`HTTPS`过程中的一个记录吧。

#### HTTPS加密过程

最近重新了解了下`HTTP`和`HTTPS`: 首先二者都是网络传输协议;`HTTPS`在传输过程中是可以通过加密来保护数据安全的，以免用户敏感信息被第三方获取。 可以说`HTTPS`是`HTTP`的升级版、安全版。下面我们就简单看下HTTPS的加密过程，先看下图。

![](https://user-gold-cdn.xitu.io/2018/1/5/160c5b10d3f27e00?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. _**客户端发起`HTTPS`请求**_ 这个没什么好说的，就是用户在浏览器里输入一个`HTTPS`网址，然后连接到服务端的443端口。
2. _**服务端的配置**_ 采用`HTTPS`协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
3. _**传送证书**_ 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
4. _**客户端解析证书**_ 这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个\*\*\*随机值\*\*\*。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。
5. _**传送加密信息**_ 这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6. _**服务端解密信息**_ 服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7. _**传输加密后的信息**_ 这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。
8. _**客户端解密信息**_ 客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。

到了这里，`HTTPS`的整个加密过程也就差不多完成了，但是这个过程中是不是还有些概念还是不太清楚，比如`SSL`是什么，`TLS`又是什么，他们是怎么验证我们的证书是否有效的呢，它们的验证策略又是怎样的呢。别急，下面我们就讨论下`TLS`。

#### TLS

刚开始听到`TLS`的时候，你可能还不太熟悉，但是说起`SSL`你可能就觉得好耳熟了。其实`TLS`就是从`SSL`发展而来的，只是`SSL`发展到3.0版本后改成了`TLS`。

> `TLS`主要提供三个基本服务

* 加密
* 身份验证，也可以叫证书验证吧~
* 消息完整性校验

第三个是网络协议中常用的一个校验和机制，我这我们就先按下不表。

**加密**

我们再看一遍客户端和服务端之间的加密机制：

![TLS&#x63E1;&#x624B;](https://user-gold-cdn.xitu.io/2018/1/5/160c5b10bd43477d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

`TLS`协议是基于`TCP`协议之上的，图中第一个蓝色往返是`TCP`的握手过程，之后两次橙色的往返，我们可以叫做`TLS`的握手。握手过程如下：

1. `client1`：`TLS`版本号+所支持加密套件列表+希望使用的`TLS`选项
2. `Server1`:选择一个客户端的加密套件+自己的公钥+自己的证书+希望使用的`TLS`选项+（要求客户端证书）；
3. `Client2`:\(自己的证书\)+使用服务器公钥和协商的加密套件加密一个对称秘钥（自己生成的一个随机值）；
4. `Server2`:使用私钥解密出对称秘钥（随机值）后，发送加密的Finish消息，表明完成握手

这里可能要提一下什么是对称加密和非对称加密： 一般的对称加密像这样：

```text
encrypt(明文，秘钥) = 密文
decrypt(密文，秘钥) = 明文
复制代码
```

也就是说加密和解密用的是同一个秘钥。而非对称加密是这样的：

```text
encrypt(明文，公钥) = 密文
decrypt(密文，私钥) = 明文
复制代码
```

加密和解密是需要不同的秘钥的。

经过这几次握手成功后，客服端和服务端之间通信的加密算法和所需要的密钥也就确定下来了，之后双方的交互都可以使用对称加密算法加密了。

**证书机制/证书验证**

在`TLS`中，我们需要证书来保证你所访问的服务器是真实的，可信的。 看这张图我们来讨论下证书的验证过程。

![&#x8BC1;&#x4E66;&#x94FE;](https://user-gold-cdn.xitu.io/2018/1/5/160c5b10bf8c36d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 客户端获取到了站点证书，拿到了站点的公钥；
2. 要验证站点可信后，才能使用其公钥，因此客户端找到其站点证书颁发者的信息；
3. 站点证书的颁发者验证了服务端站点是可信的，但客户端依然不清楚该颁发者是否可信；
4. 再往上回溯，找到了认证了中间证书商的源头证书颁发者。由于源头的证书颁发者非常少，我们浏览器之前就认识了，因此可以认为根证书颁发者是可信的；
5. 一路倒推，证书颁发者可信，那么它所颁发的所有站点也是可信的，最终确定了我们所访问的服务端是可信的；
6. 客户端使用证书中的公钥，继续完成`TLS`的握手过程。

_**那么，客户端是是如何验证某个证书的有效性，或者验证策略是怎样的?**_

证书颁发者一般提供两种方式来验证证书的有效性： _**CRL**_ 和 _**OCSP**_。

> _**CRL**_

`CRL（Certificate Revocation List）`即 _**证书撤销名单**_。证书颁发者会提供一份已经失效证书的名单，供浏览器验证证书使用。当然这份名单是巨长无比的，浏览器不可能每次TLS都去下载，所以常用的做法是浏览器会缓存这份名单，定期做后台更新。这样虽然后台更新存在时间间隔，证书失效不实时，但一般也OK。

> _**OCSP**_

`OCSP(Online Certificate StatusProtocol)`即 _**在线证书状态协议**_。除了离线文件，证书颁发者也会提供实时的查询接口，查询某个特定证书目前是否有效。实时查询的问题在于浏览器需要等待这个查询结束才能继续TLS握手，延迟会更大。

以上是站点在证书颁发者的角度说明会提供的两种判断方式，实际情况下浏览器究竟会选择哪种方式判断，每个浏览器都会有自己的实现。下面是通过Chrome查看GitHub网站的证书信息：

![&#x8BC1;&#x4E66;&#x4F8B;&#x5B50;](https://user-gold-cdn.xitu.io/2018/1/5/160c5b10c0432bca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

到这里差不多了，有什么不对的地方，欢迎大家留言指出，一起学习进步！

笔者不才，有些地方还是理解不到位，若有不正之处，还请耐心指出，轻喷~。

> 参看文章

* [TLS如何保证安全](https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F24af67c40e8d)
* [图解HTTPS协议加密解密全过程](https://link.juejin.im/?target=http%3A%2F%2Fblog.csdn.net%2Faqiangsz%2Farticle%2Fdetails%2F53611665)

引用：

[https://juejin.im/post/5a4f4884518825732b19a3ce](https://juejin.im/post/5a4f4884518825732b19a3ce)



# tls 链接

个人总结：

首先 对于https 在连接建立好后，以后的数据加密都是通过对称加密算法进行加密的，目的是提高性能和速率，非对称加密的目的是加密  对称加密算法的秘钥

单向认证： 大体流程：

* 客户端向服务器端发起tls 版本等信息的请求
* 服务器端返回自己的公钥
* 客户端验证公钥有效性
* 客户端发送自己支持的对称加密算法列表
* 服务器端从中找到一个加密程度最高的算法，并且用明文方式返回给客户端（注意，单向认证是明文方式传输给客户端）
* 客户端随机产生一个随机数 作为对称加密的秘钥，用公钥加密，发送给服务器端
* 服务端使用私钥解密，获得对称加密的秘钥（随机数）
* 后续 客户端和服务器端在传输数时，会用对应的对称加密算法 和 随机数对数据进行加密

双向认证： 

双向认证比单向认证多了一个客户端也要给服务器端发送公钥，同时 对称加密方案。大体流程

* 客户端发送ssl 版本信息
* 服务器端返回ssl 版本信息，服务器公钥
* 客户端校验公钥是否合法
* **客户端校验通过后，发送自己的客户端公钥给服务器端**
* **服务器端验证客户端公钥的合法性**
* 客户端发送自己支持的对称加密方案列表给服务器端
* 服务器端选择一个加密程度高的加密方式
* **服务端用客户端的公钥对加密方案进行加密，发送给客户端（加密方案是密文的）**
* 客户端收到加密方案后，使用私钥进行解密，获得要使用的加密方案，同时客户端产生随机码 作为对称加密方案的秘钥，随机吗用服务器端的公钥加密，发送给服务器端
* 服务器端收到加密的秘钥后，用服务器端的私钥进行解密，获得对称加密的秘钥
* 后续客户端和服务器端数据传输会使用对称加密方案和秘钥进行加密



SSL/TLS在通信中主要有双向认证和单向认证，其原理基本差不多，单向认证中客户端会认证服务器端身份，服务器端不对客户端进行认证 ，双向认证要求客户端和服务端都会互相认证，即双发之间要证书交换 ，具体如下：

SSL/TLS在通信中主要有双向认证和单向认证，其原理基本差不多，单向认证中客户端会认证服务器端身份，服务器端不对客户端进行认证 ，双向认证要求客户端和服务端都会互相认证，即双发之间要证书交换 ，具体如下：

#### 一、SSL协议加密方式 <a id="&#x4E09;ssl&#x534F;&#x8BAE;&#x52A0;&#x5BC6;&#x65B9;&#x5F0F;"></a>

SSL协议即用到了对称加密也用到了非对称加密\(公钥加密\)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。

1. 对称加密 

   速度高，可加密内容较大，用来加密会话过程中的消息

2. 公钥加密 

   加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥

#### 二、单向认证 <a id="&#x56DB;&#x5355;&#x5411;&#x8BA4;&#x8BC1;"></a>

Https在建立Socket连接之前，需要进行握手，具体过程如下：

![](../../.gitbook/assets/image%20%2833%29.png)

1. 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
2. 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
3. 客户端使用服务端返回的信息验证服务器的合法性，包括：

   * 证书是否过期
   * 发型服务器证书的CA是否可靠
   * 返回的公钥是否能正确解开返回证书中的数字签名
   * 服务器证书上的域名是否和服务器的实际域名相匹配

   验证通过后，将继续进行通信，否则，终止通信

4. 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
5. 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。
6. 服务器将选择好的加密方案通过明文方式返回给客户端
7. 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器
8. 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 

   在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。

#### 三、双向认证 <a id="&#x4E94;&#x53CC;&#x5411;&#x8BA4;&#x8BC1;"></a>

双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：

![](../../.gitbook/assets/image%20%2837%29.png)

1. 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
2. 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
3. 客户端使用服务端返回的信息验证服务器的合法性，包括：

   * 证书是否过期
   * 发型服务器证书的CA是否可靠
   * 返回的公钥是否能正确解开返回证书中的数字签名
   * 服务器证书上的域名是否和服务器的实际域名相匹配

   验证通过后，将继续进行通信，否则，终止通信

4. 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端
5. 验证客户端的证书，通过验证后，会获得客户端的公钥
6. 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
7. 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式
8. 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端
9. 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端
10. 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。

文章出处：

{% embed url="http://blog.csdn.net/duanbokan/article/details/50847612" %}

参考文章：

{% embed url="http://blog.csdn.net/self\_examination/article/details/47070209" %}

引用：

[https://www.infinisign.com/faq/ssl-tls-authentication](https://www.infinisign.com/faq/ssl-tls-authentication)

  
作者：Ruheng  
链接：https://www.jianshu.com/p/c1d6a294d3c0  
來源：简书  
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

