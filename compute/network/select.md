---
网络: select 和 poll
---

# select和poll

## select和poll

### 概述

我们看到TCP客户同事处理两个输入： 标准输入和TCP套接字。 我们遇到的问题就是在客户阻塞于（标准输入上）fgets 调用期间， 服务器进程会被杀死。 服务器TCP 虽然正确的给客户TCP发送了一个FIN ， 但是既然客户进程正阻塞与从标准输入读入的过程， 它将看不到这个EOF，直到从套接字读时为止。（可能已经过了很长时间） 这样的进程需要一种预先告知内核的能力。使得内核一旦发现进程指定的一个或者多个IO条件就绪 它就通知进程。 这个能力成为IO复用。 是由select 和poll 这两个函数支持的。

有些系统提供了更为先进的让进程在一串事件上等待的机制。

### IO 复用典型 使用在下列网络应用场合

* 当客户处理多个描述符（通常是交互式输入和网络套接字时候） 必须使用IO复用。 这是我们早先描述过的场合。
* 一个 客户同时处理多个套接字是可能的， 不过比较少见
* 如果一个TCP 服务器既要处理监听套接字 又要处理已连接套接字， 一般就要使用IO 复用
* 如果一个服务器既要处理TCP 又要处理UDP，一般就要使用IO复用
* 如果一个服务器要处理多个服务或者多个协议， 一般就要使用IO复用

IO复用并非只限于网络编程， 许多重要的应用程序也需要这项技术

### IO模型

在介绍select 和poll 两个函数之前， 我们需要回顾整体。 查看Unix 下5种IO模型的基本区别：

* 阻塞式IO
* 非阻塞式IO
* IO 复用 （select 和poll）
* 信号驱动式 IO（SIGIO）
* 异步IO

  一个输入操作通常包括两个阶段：

* 等待数据准备好
* 从内核向进程复制数据

对于一个套接字上的输入操作， 第一步通常涉及等待数据从网络中到达。当所等待分组到达时候， 它被复制到啮合的某个缓存区中。第二步就是把数据从内核缓冲区复制到应用进程的缓冲区。

#### 阻塞式IO模型

最流行的IO模型是阻塞式IO 模型， 以数据包套接字UDP作为例子， 如下图所示

![](../../.gitbook/assets/image%20%2832%29.png)

**我们使用UDP 而不是TCP作为例子的原因在于UDP而言。 数据准备好读取的概念比较简单， 要么整个数据包已经收到， 要么还没有。 然而对于TCP来说， 诸如套接字低水位标记（low-water mark）等额外变量开始起作用。 导致这个概念变得复杂**

在本节中， 我们吧recvfrom 函数视为系统调用， 因为我们正在区分应用程序和内核。 不论它如何实现。一般都会从应用程序进程空间中运行切换到内核空间中。 一段时间再切换回来。

在6-1中， 进程调用recvfrom ， 其系统调用知道数据报文到达并且会被复制到进程的缓冲区中， 或者发生错误时候才返回。 我们说进程在从调用recvfrom开始到他返回的整个时间段内是被阻塞的， recvfrom 成功返回后，应用程序开始处理数据报文。

#### 非阻塞式IO模型

进程把一个套接字设置成非阻塞是在通知内核。当所请求的IO操作非得把本进程投入睡眠才能完成时候， 不要把本进程投入睡眠。而是返回一个错误。 如下图

![](../../.gitbook/assets/image%20%2820%29.png)

前三次调用recvfrom 时候，并没有数据可以返回， 因此内核立刻返回一个 EWOULDBLOCK错误， 第四次调用recvfrom时候，已经有数据报文准备好， 它被复制到应用进程缓冲区中。于是recvfrom 成功返回， 我们接着处理数据。

当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时候， 我们称之为轮训（polling）。应用程序持续轮训内核，以查看某个操作是否有序。这么做往往耗费大量CPU。

#### IO 多路复用模型

有了IO复用， 我们就可以调用select 或者poll， 阻塞在这两个系统调用的某一个上（**注意是阻塞**），而不是阻塞在真正的IO 系统调用上。下图表示了IO复用的模型

![](../../.gitbook/assets/image%20%286%29.png)

我们调用select 调用， 等待数据报套接字变为可读， 当select 返回套接字可读这一个条件时候， 我们调用recvfrom把所读数据包复制到应用进程缓冲区。

比较图6-3 和 6-1 ，IO复用并不显得多么优势，不过使用select 的优势在于我们可以等待多个描述符就绪。

**注意（与IO复用 密切相关的另一种IO模型是在多线程中使用阻塞式IO，这种模型与上述模型极为相似， 蛋它并没有使用select 阻塞在多个文件描述符上，而是使用多个线程 ，这样每个线程都可以自由的调用诸如recvfrom之类的阻塞式IO系统调用了）**

#### 信号驱动式IO模型

我们也可以用信号， 让内核在描述符就绪时候发送SIGIO信号通知我们， 我们称这种模型为信号驱动式IO，下图是它的概要。

![](../../.gitbook/assets/image%20%285%29.png)

我们首先开启套接字的信号驱动式IO功能， 并通过sigaction系统调用安装一个信号处理函数。该系统调用将立刻返回，我们的进程继续工作， 也就是说它没有被阻塞。 当数据报准备好读取时候， 内核就为该进程产生一个SIGIO信号， 我们随后既可以在信号处理函数中调用recvfrom读取数据报文。并通知主循环数据已经准备好待处理。也可以立即通知主循环， 让它读取数据报。

无论如何处理SIGIO 信号， 这种模型的优势在于等待数据包到达期间 进程不被阻塞。 主循环也可以继续执行。 只要等待来自信号处理函数的通知： 既可以是数据已准备好被处理， 也可以是数据报已准备好被读取。

#### 异步IO模型

异步IO由POSIX 规范定义。一般的说 这些函数的工作机制是， 告知内核启动某个操作， 并让内核在整个操作（包括讲数据从内核复制到我们自己的缓冲区）完后后告知我们。 这种模型与信号驱动模型主要区别在于： 信号驱动式IO是由内核通知我们何时启动一个IO操作， 而异步IO模型是由内核通知我们IO操作何时完成。

![](../../.gitbook/assets/image%20%2822%29.png)

我嫩调用aio\_read 函数 ， 给内核传递描述符， 缓冲区指针， 缓冲区大小和文件偏移。并告诉内核整个操作完成时候如何通知我们。 该系统调用立刻返回，并且在等待IO完成期间， 我们的进程并不被阻塞。本例子中我们假设要求内核在操作完成时候产生某个信号。该信号直到数据已经复制到应用进程缓冲区才产生。这一点不同于信号驱动式IO模型。

### 各种IO模型的比较

![](../../.gitbook/assets/image%20%2823%29.png)

根据上述定义， 我们的前四种模型 -- 阻塞式IO模型，非阻塞式IO模型， IO多路复用模型和信号驱动IO模型 都是同步IO模型， 因为其中真正的IO操作（recvfrom）将阻塞进程。只有异步IO模型与POSIX定义的异步IO相匹配。

## select 函数

该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或者多个事件发生或者经历一段时间后才唤醒它。

作为一个例子， 我们可以调用select ， 告知内核仅在下列情况发生时候才返回：

* 集合 {1， 4， 5 } 中的任何描述符准备好读
* 集合 {2, 7 } 中任何描述符准备好写
* 集合 {1,4} 中的任何描述符有异常条件准备去处理
* 已经经历了 10.2 秒

也就是说， 我们调用select 告知内核对哪些描述符（就读， 写或者异常条件）感兴趣以及等待多长时间。我们感兴趣的描述符不限于套接字， 任何描述符都可以用select 来测试。

```text
int select(int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *expectset, const struct timeval *timeout)

返回： 若有就绪描述符则为其数目， 若超时则为0， 若出错则为 -1
```

我们从改函数的最后一个参数timeout 开始介绍， 他告知内核等待所指定描述符中的任何一个就绪可花多长时间。其timeval 结构用于指定时间的描述和微秒数。

这个参数有以下三种可能：

* 永远等待下去： 仅仅在有一个描述符准备好IO时候才返回，因此我们把改参数设置为空指针，其实是阻塞等待
* 等待一段固定时间： 在有一个描述符准备好IO返回时候， 但是不超过由改参数所指向的timeval结构中的秒数和微秒数
* 根本不等待： 检查描述符后立刻返回， 这成为轮训（polling）为此， 该参数必须指向一个timeval 结构。而且其中的定时器值必须为0

中间的三个参数，readset,writeset, expectset 指定我们要让内核测试读， 写 和异常条件的描述符。

**select 最大描述符在Unix 下256 ， 在Linux 下是1024**

## shutdown 函数

终止网络连接的通常方法是调用close 函数。 不过close 有两个限制，却可以使用shutdown 来避免

* close 把描述符的引用计数减一， 仅在改计数变为0 时候， 才关闭套接字。 在之前也讨论过， 使用shutdown 可以不管引用计数就激发TCP 正常连接终止序列。
* close 终止度和写两个方向的传送， 既然TCP是全双工的。 有时候我们需要告知对端我们已经完成了数据发送， 即使对端仍有数据要发送给我们。

![](../../.gitbook/assets/image%20%2835%29.png)

