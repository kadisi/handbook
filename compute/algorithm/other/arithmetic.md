---
计算机知识: 算法 算术运算
---

# 加法
见 leetcode 371

加法计算法则 跟 异或 和 与 运算有关

计算机的加法和乘法都是模拟人做加法和乘法的方法来设计和实现cpu算术运算模块的， 下面的例子

```
	1 1 0 1
		1 1
+
----------------
  1 0 0 0 0 
```
这个计算可以分为两个部分， 一部分是按位相加的，另一部分是进位的。
按位相加 其实对于二进制来说是异或运算了，相同为0 相异为1,  如 1 + 1 = 0 ， 0 + 1 = 1， 1 + 0 = 1， 0 + 0 = 0
那么什么情况下进位， 1 + 1 的时候才进位， 我们应该马上会想到是与运算， 进的哪一位加到高位继续参加下一步的运算。
那么我们会得到下面的公式：

`a + b = (a&b) << 1 + a ^ b`

但是a + b 的实现里还是用到了加法， 所以这是一个递归，那么什么是递归截止的终止条件呢， 就是进位的数为0的情况， 也就是(a&b)<<1 为0 时候
于是我们得到了如下代码：
```
func getSum(a int, b int) int {
    if a == 0 {
        return b
    }
    return getSum((a&b)<<1, a^b)
}
```

# 减法

减法计算法则跟补码有关

加法是进位， 减法按照正常人的思维 则是需要借位,是这样吗？
按照我们小时候对加减法的学习经验是这样的，但是计算机并不是这么处理的。 我们需要了解另一个概念： **补码**

**补码**
我们知道， 计算机对于有符号数， 用最高位作为符号位，`0` 代表 `+`, `1`代表`-`, 其余数位用做数值位 ，代表数值, 怎么推导一个数字的补码呢？
补码规定：正数和0的补码就是其原码，负数的补码是其正数的原码取反 再 加1
举个例子： 求-10 的补码:
十进制 10 的原码 （按照8位距离）为 0000 1010, 其反码为 1111 0101，再加1 为 1111 0110, 因此-10 的补码 为 1111 0110
那么我们再回到减法计算上来：
a = b - c
实际上等同于
a = b + (-c)
那么我们计算下面的式子：
* 12 - 5
= 0000 1100 + （5 的二进制 0000 0101 的取反 1111 1010 再加1 为 1111 1011）
= 0000 1100 + 1111 1011
=(1)0000 0111
= 7

* 7 - 9
= 0000 0111 + (9 的二进制 0000 1001 取反 1111 0110 再加1为 1111 0111)
= 0000 0111 + 1111 0111
= 1111 1110
= (求正数 1111 1110 减一 为 1111 1101 取反 0000 0010 为 2)
= -2

# 乘法
乘法的原理其实是跟我们做乘法的思想有点类似， 只不过计算机做乘法是通过位移和加法运算的。
举例：
* 5 \* 3
= 0000 0101 \* 0000 0011





























