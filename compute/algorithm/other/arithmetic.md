---
计算机知识: 算法 算术运算
---

# 加法
见 leetcode 371

加法计算法则 跟 异或 和 与 运算有关

计算机的加法和乘法都是模拟人做加法和乘法的方法来设计和实现cpu算术运算模块的， 下面的例子

```
	1 1 0 1
		1 1
+
----------------
  1 0 0 0 0 
```
这个计算可以分为两个部分， 一部分是按位相加的，另一部分是进位的。
按位相加 其实对于二进制来说是异或运算了，相同为0 相异为1,  如 1 + 1 = 0 ， 0 + 1 = 1， 1 + 0 = 1， 0 + 0 = 0
那么什么情况下进位， 1 + 1 的时候才进位， 我们应该马上会想到是与运算， 进的哪一位加到高位继续参加下一步的运算。
那么我们会得到下面的公式：

`a + b = (a&b) << 1 + a ^ b`

但是a + b 的实现里还是用到了加法， 所以这是一个递归，那么什么是递归截止的终止条件呢， 就是进位的数为0的情况， 也就是(a&b)<<1 为0 时候
于是我们得到了如下代码：
```
func getSum(a int, b int) int {
    if a == 0 {
        return b
    }
    return getSum((a&b)<<1, a^b)
}
```

# 减法

减法计算法则跟补码有关

加法是进位， 减法按照正常人的思维 则是需要借位,是这样吗？
按照我们小时候对加减法的学习经验是这样的，但是计算机并不是这么处理的。 我们需要了解另一个概念： **补码**

**补码**
我们知道， 计算机对于有符号数， 用最高位作为符号位，`0` 代表 `+`, `1`代表`-`, 其余数位用做数值位 ，代表数值, 怎么推导一个数字的补码呢？
补码规定：正数和0的补码就是其原码，负数的补码是其正数的原码取反 再 加1
举个例子： 求-10 的补码:
十进制 10 的原码 （按照8位距离）为 0000 1010, 其反码为 1111 0101，再加1 为 1111 0110, 因此-10 的补码 为 1111 0110
那么我们再回到减法计算上来：
a = b - c
实际上等同于
a = b + (-c)
那么我们计算下面的式子：
* 12 - 5
= 0000 1100 + （5 的二进制 0000 0101 的取反 1111 1010 再加1 为 1111 1011）
= 0000 1100 + 1111 1011
=(1)0000 0111
= 7

* 7 - 9
= 0000 0111 + (9 的二进制 0000 1001 取反 1111 0110 再加1为 1111 0111)
= 0000 0111 + 1111 0111
= 1111 1110
= (求正数 1111 1110 减一 为 1111 1101 取反 0000 0010 为 2)
= -2

# 乘法
乘法的原理其实是跟我们做乘法的思想有点类似， 只不过计算机做乘法是通过位移和加法运算的。
举例：
* 5 \* 3
= 0000 0101 \* 0000 0011

5 乘以 3 ，代表了三个五 相加， 根据3 的二进制表示 0011 可以理解为 1 个五 + 2个五
按照这种思想 可以这么理解
3 的第 0 位 为 1， 因此需要将5左移0 位， 还是5
3 的第1位 为 1，因此需要将5 左移1位， 得 0000 1010 为10
两者相加 5 + 10 = 15

同样 对于
* 3 \* 5
= 0000 0011  \* 0000 0101
5的第0位为1 ,需要将3左移0位， 为 3
5的第1位为0， 不做操作
5的第2位为1， 需要将3左移2位， 为 0000 1100 为 12
3 + 12 为 15

golang 实现两个数相乘， 不用 加减乘除
```

// i是从右边开始算， 范围是[0,31]闭区间
var MASK int32 = 0x01

func getBitValue(value int32, i uint) int32 {
    return (value >> i) & MASK
}

func Muilty(v1, v2 int32) int32 {
    var value int32 = 0
    var i uint = 0
    for ; i<=31; i= uint(Sum(int32(i), 1)) {
        if getBitValue(v2, i) == 1 {
            value = Sum(value, (v1 << i))
        }
        if v2 >> i == 0 {
            break
        }
    }
    return value
}

func Sum(a, b int32) int32{
    if a == 0 {
        return b
    }
    return Sum((a&b)<<1, a^b)
}

```





























