---
计算机知识: 信号 
---

# 信号本质

软中断信号（signal 又称为信号）用来通知进程发生了异步事件， 在软件层次上是对中断机制的一种模拟。 在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的， 信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达。

事实上， 进程也不知道信号到底什么时候到达， 进程之间可以互相通过操作系统调用kill发送软中断信号。 内核也可以因为内部事件而给进程发送信号。 通知进程发生了某个事件， 信号机制除了基本通知功能外， 还可以传送附加信息。

收到信号的进程对各种信号有不同的处理方法， 处理方法可以分为三类：

* 类似终端的处理程序， 对于需要处理的信号， 进程可以指定处理函数， 由该函数来处理

* 忽略某个信号， 对改信号不做任何处理， 就像未发生过一样

* 对信号的处理保留系统的默认值， 这种缺省操作， 对大部分信号的缺省操作是似的进程终止。进程通过调用signal 来指定进程对某个信号的处理行为。


# 信号种类

可以从两个不同的分类角度对信号进行分类。


* 可靠性方面 : 可靠信号与不可靠信号

* 与时间的关系上：实时信号与非实时信号


# 信号处理流程

对于一个完整的信号声明周期，（从信号发送到相应的处理函数执行完毕）来说， 可以分为三个阶段：

* 信号诞生

* 信号在进程中注册

* 信号的执行和注销

## 信号的诞生
信号事件的发生有两个来源：硬件来源， （比如我们按下了键盘或者其他硬件故障）， 软件来源，最常用发送信号的系统函数是kill ， raise ， alarm，和sigqueue函数， 

这里按照发出信号的原因简单分类， 以了解各种信号：

（1） 与进程终止相关的信号。当进程退出，或者子进程终止时，发出这类信号。

（2） 与进程例外事件相关的信号。如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误。

（3） 与在系统调用期间遇到不可恢复条件相关的信号。如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。

（4） 与执行系统调用时遇到非预测错误条件相关的信号。如执行一个并不存在的系统调用。

（5） 在用户态下的进程发出的信号。如进程调用系统调用kill向其他进程发送信号。

（6） 与终端交互相关的信号。如用户关闭一个终端，或按下break键等情况。

（7） 跟踪进程执行的信号。



## 信号在进程中的注册
在进程表的表项中有一个软中断信号域， 该域中每一位对应一个信号， 内核给一个进程发送软中断信号的方法， 是在进程所在的进程表项的信号域设置对应的该信号的位，如果信号发送给一个正在睡眠的进程。如果进程睡眠在可被中断的优先级上， 则唤醒进程。否则仅仅设置进程表信号域相应的位， 而不唤醒进程，如果发送给一个处于可运行状态的进程， 则直接设置相应的域即可。

```
进程的task_struct结构中有关于本进程中未决信号的数据成员： struct sigpending pending：

struct sigpending{

        struct sigqueue *head, *tail;

        sigset_t signal;

};
```

第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个sigqueue类型的结构链（称之为"未决信号信息链"）的首尾，信息链中的每个sigqueue结构刻画一个特定信号所携带的信息，并指向下一个sigqueue结构:

```
struct sigqueue{

        struct sigqueue *next;

        siginfo_t info;

}
```

信号在进程中的注册指的就是信号值加入到进程的未决信号集 `sigset_t signal 每个信号占一位`中， 并且信号所携带的信息被保留到未决信号链的某个sigqueeue结构中， 只要信号在进程的未决信号集中， 表明进程已经知道这些信号的存在， 蛋还没来得及处理， 或者改信号被进程阻塞

当一个实时信号发送给一个进程时候， 不管改信号是否已经在进程中注册， 都会被注册一次， 因此信号不会丢失。 因此实时信号 又叫做可靠信号。 就意味着同一个实时信号可以在同一个进程中的未决信号信息链中占有多个sigqueue结构。

总之 信号注册与否， 与发生信号的函数（如kill 或者sigqueue） 以及信号安装函数（signal（）以及sigaction（））无关， 只与信号值有关 。

 
## 信号的执行和注销 

内核处理一个进程收到的软中断信号是在该进程的上下文中， 因此进程必须处于运行状态。当其由于被信号唤醒或者正常调度中心获得CPU时候， 在其从内核空间返回到用户空间时候会检测是否有信号等待处理，如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前， 进程会把信号在未决信号链中占有的结构卸载掉。

当所有未被屏蔽的信号都处理完毕后， 即可以返回用户空间

内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时候，所以当一个进程在内核态下运行时， 软中断信号并不立即起作用， 要等到将返回用户态时才处理， 进程只有处理完信号才返回用户态。进程在用户态下， 不会有未处理完的信号。

# 信号的安装

如果进程要处理某一个信号， 那么就要在进程中安装该信号， 安装信号主要用来确定信号值以及进程对改信号值的动作之间的映射关系。 即进程将要处理哪个信号， 该信号被传递给进程时候， 将要执行何种操作。



























