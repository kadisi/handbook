---
操作系统: 线程
---

# 线程

## 概述

传统UNIX模型中， ，当一个进程需要另一个实体来完成某事时候， 它就fork一个子进程， 并让子进程去执行处理。 Unix 大多数网络服务器程序就是这么写的： 父进程accept 一个链接， fork 一个子进程， 该子进程处理与连接对端的客户之间的通信。

尽快这种范式多少年来一直用的很好， fork 调用却存在一些问题。

* fork 是昂贵的。 fork 要把父进程的内存映像复制到子进程。 并在子进程中复制所有描述符， 如此等等。 当今实现使用并成为写时复制（copy on write）的技术， 可以避免在子进程切实需要自己的副本之前把父进程的数据空间复制到子进程， 然而几遍有这样的优化措施， fork 仍然是昂贵的
* fork 返回之后， 父子进程之间的信息传递需要通过进程间通信（IPC）机制。 调用fork 之前， 父进程向尚未存在的子进程传递信息相当容易， 因为子进程将从父进程数据空间以及所有描述符的一个副本开始运行， 然后子进程往父进程返回信息却比较费力。

线程有助于解决这两个问题， 线程有时称为轻权线程（lightweight process）因为线程比进程权重轻一些， 也就是说线程创建可能比进程创建快10-100倍。

统一进程内的所有线程共享相同的全局内存。 这使得线程之间易于共享信息， 然后伴随这种简易型 而来的确实同步（**synchronization** ）问题。

同一进程内的所有线程除了共享全局变量外还共享：

* 进程指令
* 大多数数据
* 打开的文件， 即（M描述符）
* 信号处理函数和信号处置
* 当前工作目录
* 用户ID和组ID

不过每个线程有各自的：

* 线程ID
* 寄存器集合， 包括程序计数器和栈指针
* 栈 （用于存放局部变量和返回地址）
* error
* 信号掩码
* 优先级

## pthread\_create 函数

当一个程序有exec 启动执行时候， 成为初始线程\(initial thread\) 或者主线程（main thread）的单个线程就创建了。 其余线程则有pthread\_create 函数创建

```text
int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);

返回： 若成功则为0， 若出错则为正的EXXX 值
```

一个进程内的每个线程都有一个线程ID 标示， 其数据类型为pthread\_t \(往往是unsigned int\) 如果新的线程成功创建， 其ID 就通过tid 指针返回

每个线程都有许多属性（attribute）：优先级， 初始栈大小， 是否应该成为一个守护线程等等。

## pthread\_join 函数

我们可以通过调用pthread\_join 等待一个给定线程终止， 对比线程和Unix 进程， pthread\_create 类似于fork， pthred\_join 类似于waitpid

```text
int pthread_join(pthread_t *tid, void ** status);

返回： 若成功则为0， 若出错则为正的Exxx值
```

我们必须制定要等待线程的tid， 不幸的是pthread 没有办法等待任意一个线程（类似制定进程ID参数为-1 调用waitpid）

pthread\_join 类似于golang的sync.WaitGroup, 哈哈哈

## pthread\_detach 函数

一个线程或者是可汇合的（joinable 默认值）， 或者是脱离的（detached）, 当一个可汇合的线程终止时， 它的线程ID和退出状态将留存到另一个线程对它调用pthread\_join。 脱离的线程却像守护进程， 当他们终止时候， 所有相关资源都被释放， 我们不能等待他们终止。

如果一个线程需要知道另一个线程什么时候终止， 那就最好保持第二个线程可汇合状态。

## pthread\_exit 函数

让一个线程终止的方法之一是调用pthread\_exit

```text
void pthread_exit(void *status)
```

如果本线程未曾脱离， 它的线程ID 和 退出状态将一直留存到调用进程的某个其他线程对它调用pthread\_join

指针status 不能指向局部于调用线程的对象， 因为线程终止时这样的对象也消失。

让一个线程终止的另外两个方法是：

* 启动线程的函数（即pthread\_create的第三个参数）可以返回， 既然该函数必须声明称返回一个void 指针， 它的返回值就是相应线程的终止状态
* 如果进程的main 函数返回或者任何线程调用了exit，整个进程就终止。 其中包括他的任何线程。

## 线程引申而来的同步问题

## 互斥锁

互斥锁适合于防止同时访问某个共享变量

## 条件变量

如果我们需要另外某种等待某个条件发生期间能让我们进入睡眠的东西。我们应该使用条件变量

