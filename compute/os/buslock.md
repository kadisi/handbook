---
操作系统 总线索 
---

# 总线锁

所谓原子操作,就是"不可中断的一个或一系列操作" 。

硬件级的原子操作

在单处理器系统(UniProcessor)中，能够在单条指令中完成的操作都可以认为是" 原子操作"，因为中断只能发生于指令之间。这也是某些CPU指令系统中引入了test_and_set、test_and_clear等指令用于临界资源互斥的原因。

在对称多处理器(Symmetric Multi-Processor)结构中就不同了，由于系统中有多个处理器在独立地运行，即使能在单条指令中完成的操作也有可能受到干扰。

** 在x86 平台上，CPU提供了在指令执行期间对总线加锁的手段。CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀"LOCK"，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的 **

原子性。

软件级的原子操作

软件级的原子操作实现依赖于硬件原子操作的支持。

对于linux而言，内核提供了两组原子操作接口一组是针对整数进行操作；另一组是针对单独的位进行操作。

2.1. 原子整数操作

针对整数的原子操作只能对atomic_t类型的数据处理。这里没有使用C语言的int类型，主要是因为

1) 让原子函数只接受atomic_t类型操作数，可以确保原子操作只与这种特殊类型数据一起使用

2) 使用atomic_t类型确保编译器不对相应的值进行访问优化

3) 使用atomic_t类型可以屏蔽不同体系结构上的数据类型的差异。尽管Linux支持的所有机器上的整型数据都是32位，但是使用atomic_t的代码只能将该类型的数据当作24位来使用。这个限制完全是因为在SPARC体系结构上，原子操作的实现不同于其它体系结构32位int类型的低8位嵌入了一个锁，因为SPARC体系结构对原子操作缺乏指令级的支持，所以只能利用该锁来避免对原子类型数据的并发访问。

原子整数操作最常见的用途就是实现计数器。原子整数操作列表在中定义。原子操作通常是内敛函数，往往通过内嵌汇编指令来实现。如果某个函数本来就是原子的，那么它往往会被定义成一个宏。


#总线锁
总线索就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。

#缓存锁
由于，我们只需要保证对某个内存地址的操作是原子的即可，但是总线锁把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器也不能操作其他内存地址的数据，所以总线锁的开销比较大。目前，处理器在某些场合下使用缓存锁来代替总线索进行优化。

缓存锁就是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK#操作期间，那么当它执行操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效。


#使用场景
如上面所说，在多数情况下，处理器还是使用缓存锁来代替总线锁，但是在下面两种情况下，我们还是使用总线锁来完成相应保证一致性。

情况1当操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，则处理器会字调用总线锁锁定。
情况2有些处理器不支持缓存行锁定。

