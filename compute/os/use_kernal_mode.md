---
计算机知识: 用户态和内核态 
---

# 简介

linux 驱动程序一般工作在内核空间， 但是也可以工作在用户空间。 下面我们将详细解析， 什么是内核空间，什么是用户空间， 以及如何判断他们。

Linux 简化了分段机制， 似的虚拟地址与线性地址总是一致， 因此Linux的虚拟地址空间也分为0~4G (32位情况下),Linux 内核将这4G字节的空间分为2部分。 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。

因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。

linux 使用两级保护机制， 0级供内核使用， 3级供用户程序使用。 每个进程有各自的私有用户空间（0-3G）这个空间对系统中的其他进程是不可见的。 最高的1GB字节虚拟内核空间则为所有进程以及内核所**共享**


内核空间中存放的是**内核代码和数据**，而进程的用户空间中存放的是**用户程序的代码和数据** , 不管是内核空间还是用户空间， 他们都处于虚拟空间中， 虽然内核空间占据每个虚拟空间中的最高1GB字节， 但是映射到物理内存却总是从最低地址（0x00000000）开始， 对内核空间来说， 其地址映射是很简单的线性映射。


内核空间和用户空间之间如何进行通信？

内核空间和用户空间一般通过系统调用进行通信。

如何判断一个驱动是用户模式驱动还是内核模式驱动， 判断的标准是什么？

用户空间模式的驱动一般通过系统调用完成对硬件的访问， 如通过系统调用将驱动的io空间映射到用户空间等。因此主要的判断依据就是系统调用，

内核空间和用户空间上有太多的不同， 比如用户态的链表和内核链表不一样。

用户态每个应用程序空间是虚拟的， 相对独立的， 内核态中却不是是独立的， 所以变成要非常小心等等。

还有用户态和内核态程序通讯的方法很多， 不单单是系统调用， 实际上系统调用是一个不好的选择， 因为需要系统调用号， 这个需要统一分配。

可以通过ioctl ， sysfs，proc 等来完成。


# 内核态和用户态

当一个进程执行系统调用而陷入内核代码中执行时候， 我们就称进程处于内核运行态 或者简称 内核态。  此时处理器出去特权级最高的（0级）内核代码中执行。 当进程处于内核态时候， 执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。当进程在执行用户自己的代码时候 ，则称其处于用户运行态（用户态）， 即此时处理器在特权等级最低的（3级） 用户代码中运行， 当正在执行用户程序而突然被中断程序中断时候， 此时用户程序也可以象征性的成为处于进程的内核态。 因为中断处理程序将使用当前进程的内核栈。 这与处于内核态进程的状态有些类似。


## 内核栈

在C语言书里面讲的栈， 堆， 大部分都是用户态的概念。 用户态的堆栈，对应用户进程虚拟地址空间的一个区域， 栈向下增长， 堆用malloc 分配， 向上增长。

用户空间的堆栈， 在task_struct -> mm -> vm_area 里面描述，都是属于进程虚拟地址空间的一个区域

而内核态的栈在task_struct -> stack 里面描述， 其底部是thread_info 对象， thread_info 可以用来快速获取task_struct对象， 整个stack区域一般只有一个内存页面， 32位机器也就4KB

所以说 一个进程的内核栈 也是进程私有的， 只是在task_struct -> stack Lim 获取。 

内核态里没有进程堆的概念。

# 进程上下文和中断上下文

处理器总是处于以下状态中的一种：

* 内核态， 运行于进程上下文， 内核代表进程运行于内核空间

* 内核态， 运行于中断上下文， 内核代表英健运行于内核空间

* 用户态， 运行于用户空间

用户空间的应用程序， 通过系统调用， 进入内核空间。 这时候用户空间的进程要传递很多变量， 参数的值给内核。 内核态运行的时候也要保存用户进程的一些寄存器，变量等等。 所谓的进程上下文，可以看做是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器只和当时的环境等等。 

硬件通过出发信号， 导致内核调用中断处理程序， 进入内核空间， 这个过程中， 硬件的一些变量和参数也要传递给内核。 内核通过这些参数进行中断处理， 所谓的中断上下文， 其实也看做是硬件传递过来的这些参数和内核需要保存的一些其他环境。


# 内核虚拟空间布局

在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中， 这个沙盘就是虚拟地址空间（virtual address space）在32位模式下， 它是一个4GB的内存地址， 在Linux 系统中 内核进程和用户进程所占的虚拟内存比是1：3 而window 系统为2：2 ， 这并不意味着内核使用那么多的物理内存， 仅仅表示它可以支配这部分地址空间， 根据需要映射到物理内存。

虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。

Linux进程在虚拟内存中的标准内存段布局如下图所示：

















































































